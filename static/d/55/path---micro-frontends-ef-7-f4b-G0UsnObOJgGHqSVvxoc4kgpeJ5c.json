{"data":{"site":{"siteMetadata":{"title":"DailyJSX","author":"Nadun Indunil"}},"markdownRemark":{"id":"556bd525-744c-595c-88ae-b31cb5125204","html":"<p>Implementing and maintaining a frontend is relatively harder than a backend project. It could get even worse if you have a huge frontend with different teams to develop different UI pieces. You might have seen teams trying to struggle with huge UIs to manage and their codebases with following various methods. Sometimes they rewrite their whole frontend architecture to solve this issue. However, there is an answer to the struggle, Micro Frontends.</p>\n<p>The very first thing someone would ask is, when should we use micro frontend architecture. It could be listed as below,</p>\n<ul>\n<li>You have different teams to develop a huge application</li>\n<li>You need sperate deployments for separate applications’ UIs</li>\n<li>You need to use different UI frameworks for frontend</li>\n</ul>\n<h2 id=\"benefits-of-micro-fe-architecture\"><a href=\"#benefits-of-micro-fe-architecture\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benefits of Micro FE Architecture</h2>\n<p>Adhering to Mirco-FE architecture would provide you various benefits. Among many, I would like to discuss the following,</p>\n<ul>\n<li><strong>Maintainable small code base</strong> - The frontend code base will be divided into smaller frontends which is more easier to maintain. In addition to that, the Decoupled codebase minimizes the ability to propagate a bug from code change to the whole application. (I would suggest to avoid or minimize the coupling between micro frontends. Coupling between micro frontends would make implementation and decision making harder for developers.)</li>\n<li><strong>Incremental upgrades</strong> - This smaller codebase would allow you to update or even rewrite your application in an incremental manner which you found almost impossible in a monolithic frontend. Hereafter, the development team can adapt to a new frontend technology even the starting point of the application was much older technology. Which you may upgrade in a later phase of the development cycle.</li>\n<li><strong>Independent deployments</strong> - Micro frontends can be deployed independently (Just as a typical microservice). This would give us more chances to minimize the scope of effect when a deployment happens to the frontend and even easy to debug or identify what went wrong after a deployment.</li>\n<li><strong>Autonomous teams</strong> - The decoupled codebase would allow development teams to develop and deploy independently. This is a huge plus point when you have several teams to develop one application.</li>\n</ul>\n<p>However, there are a few challenges of using micro frontends architecture,</p>\n<ul>\n<li><strong>Initial application payload size</strong> - Since every micro application is going to duplicate dependencies and several code lines, the initial app load time size for an application would be higher. The overall application size would be larger than a monolithic application. (It is obvious since every micro app would contain duplicated dependencies n times)</li>\n<li><strong>Difficulty to local development</strong> - Since micro frontends cannot initialize without the container application local development needs both applications to run simultaneously. In addition to that, the codebase of a micro application is slightly different than a usual application thus, developers need to code changes to start a micro application independently. (Even though an application could work separately, depends on the framework or the technology used for micro frontend implementation, developers need to do few code changes to start application separately in local)</li>\n<li><strong>Operational and governance complexity</strong> - It is obvious since we divided the monolithic repository into smaller repositories the development team needs more testing, more pipelines, and resources to operate the application.</li>\n<li><strong>Shared data/communication between applications</strong> - In an ideal scenario a micro frontend should act independently, But practically we found many cases where we required to communicate back and forth between micro applications. (such as shared data about the authentication/token details, a variable that should update and effect to every micro frontend, etc.). Even though we expect micro applications to develop independently at one point we might need to share some details between applications. (We can discuss this in a later article to deep dive in these challenges of micro frontend architecture)</li>\n</ul>\n<h2 id=\"implementation-methods\"><a href=\"#implementation-methods\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Implementation methods</h2>\n<p>During my research to implement micro frontends, I could found several approaches that we might call it a micro frontend approach.</p>\n<h3 id=\"client-side\"><a href=\"#client-side\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Client-Side</h3>\n<ul>\n<li><strong>Web Components</strong> - Web components are a concept of creating custom dom elements. They are like widgets that can be imported into the application.</li>\n<li><strong>Javascript integration</strong> - Frameworks like Single-SPA will help you to implement micro frontends using a javascript library.</li>\n<li><strong>iFrame</strong> - You can use iframes to inject an application. This is not a recommended approach.</li>\n</ul>\n<h3 id=\"server-side\"><a href=\"#server-side\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server-Side</h3>\n<ul>\n<li><strong>Zalandos solution</strong> - <a href=\"https://www.mosaic9.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.mosaic9.org/</a></li>\n<li><strong>Facebook’s big pipe</strong> - <a href=\"https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/</a></li>\n</ul>\n<p>Apart from all the examples given above you could custom tailor a solution for your need as you please. However, we chose Single-SPA for our requirement since we were working with serverless applications and the minimum learning curve.</p>\n<h3 id=\"overall-architecture\"><a href=\"#overall-architecture\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overall architecture</h3>\n<p>Adhering to micro frontend architecture doesn’t limit you from using standard frontend backend architecture. However, We have seen that using a BFF(Backend for Frontend) would help teams in several ways. Such as,</p>\n<ul>\n<li>Communication between several API should happen in a separate layer rather than the service layer. I believe backend microservice should be decoupled and communication between other services should happen through the BFF layer. This approach allows us to use a separate BFF for every single micro frontend which is easier to manage with our autonomous team.</li>\n<li>A BFF is actually another layer of security - When it comes to our project, We place our backend services inside a VPN. Thus, BFF is the only endpoint exposed to the public and those endpoints are well protected using authentication and Web firewalls.</li>\n</ul>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8c49876db7263f0a4abf14017b90d5d8/1a394/micro-fe-architecture.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 45.35064935064935%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsSAAALEgHS3X78AAABkklEQVQoz42SYW+bQAyG+f+/p9K0adr2Zdq3Tm2TNG2yhKRQAqEMODjguOOZIUmnqtI0S5aMfX79vjbeYB2jdc9z6sVH9P0nbDSbcoMbTj5ILN+2zqiXn6c3av6Bzv8hBTvVBudwguWZ3qC7kmL7neTuinR2hTo+ok2DdVZQDEYl2KaA4ony4Zu8+4J6+IpNHumKHFOpEwGZ7OW6YP3bZ1M+cxdtWSR7iQM2+RZtWzA1an+NjpdT00sDi7CjGoUJtZebn6j16i9gr3Pa45pexTJpR18HNHFE7W+wrQAKqM22OBmIMyhtCNOGphP2pqPd7zDxYQKbANvySO5f0+YBeTKnylaUO5/09kbAtYA06GiByfyJRS4MV6GiPq2eYnmP3p1qo3njwv9p40F0hEigKUNUciusK8qtTzafjTox1hIfDrSiyHNynQvdN37Ojw15/EvAjrLOmDpbyp0q6iCklN0NRo7W96RpegIcGy8LfedjQfbWS5OVv+F/zHP2LeCr0nPsRE7wtBdJ0Tnv3qm4+Ij1BzXithSiiQ/aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"micro frontend architecture\"\n        title=\"\"\n        src=\"/static/8c49876db7263f0a4abf14017b90d5d8/40fad/micro-fe-architecture.png\"\n        srcset=\"/static/8c49876db7263f0a4abf14017b90d5d8/707e9/micro-fe-architecture.png 148w,\n/static/8c49876db7263f0a4abf14017b90d5d8/649e0/micro-fe-architecture.png 295w,\n/static/8c49876db7263f0a4abf14017b90d5d8/40fad/micro-fe-architecture.png 590w,\n/static/8c49876db7263f0a4abf14017b90d5d8/b3fef/micro-fe-architecture.png 885w,\n/static/8c49876db7263f0a4abf14017b90d5d8/301c0/micro-fe-architecture.png 1180w,\n/static/8c49876db7263f0a4abf14017b90d5d8/b5a53/micro-fe-architecture.png 1770w,\n/static/8c49876db7263f0a4abf14017b90d5d8/1a394/micro-fe-architecture.png 1925w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    \n<em>Fig. 1: A highlevel comparison between monolithic frontend and micro frontend architecture</em></p>\n<p>The next architectural decision is to where should we handle the authentication. Authentication was a real challenge when we were developing the container(main application) in our architecture. The solution was the main container should have authentication forms and auth functions. When a session is authenticated the main application should be able to inject those details into all micro frontends. (Let’s discuss these challenges in another article for micro frontends)</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>An application frontend was the final bottleneck for the dream of autonomous and independent teams. For many years developers were struggling to develop a larger frontend without proper decoupling and cohesion. I believe this trend will help them to solve not only the issues I mentioned but also frontend engineering will be considered a serious task in the future. </p>\n<h2 id=\"references\"><a href=\"#references\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References:</h2>\n<ul>\n<li><a href=\"https://martinfowler.com/articles/micro-frontends.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://martinfowler.com/articles/micro-frontends.html</a></li>\n<li><a href=\"https://medium.com/@tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16</a></li>\n<li><a href=\"https://medium.com/@lucamezzalira/i-dont-understand-micro-frontends-88f7304799a9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@lucamezzalira/i-dont-understand-micro-frontends-88f7304799a9</a></li>\n<li><a href=\"https://www.infoq.com/news/2020/01/strategies-micro-frontends/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.infoq.com/news/2020/01/strategies-micro-frontends/</a></li>\n<li><a href=\"https://levelup.gitconnected.com/brief-introduction-to-micro-frontends-architecture-ec928c587727\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://levelup.gitconnected.com/brief-introduction-to-micro-frontends-architecture-ec928c587727</a></li>\n</ul>","timeToRead":5,"frontmatter":{"title":"Introduction to Micro Frontend","date":"March 09, 2020","spoiler":"The one with what,why,how about micro frontends","author":"Nadun Indunil","tags":["micro-fe","architecture"]},"fields":{"slug":"/micro-frontends/","langKey":"en"}}},"pageContext":{"slug":"/micro-frontends/","previous":{"fields":{"slug":"/antd-rescript-sass-boilerplate/","langKey":"en","directoryName":"antd-rescript-sass-boilerplate"},"frontmatter":{"title":"Ant Design Webpack override using rescript and antd scss theme plugin","tags":["React","webpack","antd"]}},"next":null,"translations":[],"translatedLinks":[]}}